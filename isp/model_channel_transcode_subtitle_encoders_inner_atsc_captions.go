/*
 * WBD Aventus Channels API
 *
 * API version: v1.19.22
 * Contact: live-control-plane-devs@wbd.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package isp

import (
	"encoding/json"
)

// checks if the ChannelTranscodeSubtitleEncodersInnerAtscCaptions type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ChannelTranscodeSubtitleEncodersInnerAtscCaptions{}

// ChannelTranscodeSubtitleEncodersInnerAtscCaptions Extract subtitles from the ATSC caption encodings. The captions themselves are first sourced according to the Source.captions_source field. Only one of ['teletext', 'atsc_captions'] may be set.
type ChannelTranscodeSubtitleEncodersInnerAtscCaptions struct {
	// If non-zero, decode captions from the CEA-608 logical channel number identified by this number. If zero, only CTA-708 captions will be decoded. The 'logical channel number' refers to the CCx name commonly used in literature: - CC1 is the NTSC odd field subchannel 1, considered the primary caption stream. - CC2 is the NTSC odd field subchannel 2, considered the tertiary caption stream. - CC3 is the NTSC even field subchannel 1, considered the secondary caption stream. - CC4 is the NTSC even field subchannel 2, considered the quaternary caption stream.
	Cea608 *int32 `json:"cea608,omitempty" format:"int32" minimum:"0" maximum:"4" doc:"If non-zero, decode captions from the CEA-608 logical channel number identified by this number. If zero, only CTA-708 captions will be decoded. The 'logical channel number' refers to the CCx name commonly used in literature: - CC1 is the NTSC odd field subchannel 1, considered the primary caption stream. - CC2 is the NTSC odd field subchannel 2, considered the tertiary caption stream. - CC3 is the NTSC even field subchannel 1, considered the secondary caption stream. - CC4 is the NTSC even field subchannel 2, considered the quaternary caption stream."`
	// If non-zero, decode captions from the CTA-708 service identified by this number. If zero, only CEA-608 captions will be decoded. It is allowed to set both 'cta708' and 'cea608'. In this case, the transcoder will decode both streams, and will use the CTA-708 data if the stream is active and fall back to CEA-608 otherwise. Fallback from CTA-708 to CEA-608 requires a timeout to elapse, but switching from CEA-608 to CTA-708 occurs the instant the CTA-708 stream becomes active. CTA-708 recommends the following correspondence between the two encodings: - CTA-708 service 1 == CEA-608 CC1 (primary captions) - CTA-708 service 2 == CEA-608 CC3 (secondary captions) - CTA-708 service 3 == CEA-608 CC2 (tertiary captions) - CTA-708 service 4 == CEA-608 CC4 (quaternary captions) However, some sources use an alternate convention where CTA-708 service 3 is the secondary caption service (corresponding to CC3) and CTA-708 service 2 is the tertiary caption service.
	Cta708 *int32 `json:"cta708,omitempty" format:"int32" minimum:"0" maximum:"63" doc:"If non-zero, decode captions from the CTA-708 service identified by this number. If zero, only CEA-608 captions will be decoded. It is allowed to set both 'cta708' and 'cea608'. In this case, the transcoder will decode both streams, and will use the CTA-708 data if the stream is active and fall back to CEA-608 otherwise. Fallback from CTA-708 to CEA-608 requires a timeout to elapse, but switching from CEA-608 to CTA-708 occurs the instant the CTA-708 stream becomes active. CTA-708 recommends the following correspondence between the two encodings: - CTA-708 service 1 == CEA-608 CC1 (primary captions) - CTA-708 service 2 == CEA-608 CC3 (secondary captions) - CTA-708 service 3 == CEA-608 CC2 (tertiary captions) - CTA-708 service 4 == CEA-608 CC4 (quaternary captions) However, some sources use an alternate convention where CTA-708 service 3 is the secondary caption service (corresponding to CC3) and CTA-708 service 2 is the tertiary caption service."`
}

// NewChannelTranscodeSubtitleEncodersInnerAtscCaptions instantiates a new ChannelTranscodeSubtitleEncodersInnerAtscCaptions object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewChannelTranscodeSubtitleEncodersInnerAtscCaptions() *ChannelTranscodeSubtitleEncodersInnerAtscCaptions {
	this := ChannelTranscodeSubtitleEncodersInnerAtscCaptions{}
	return &this
}

// NewChannelTranscodeSubtitleEncodersInnerAtscCaptionsWithDefaults instantiates a new ChannelTranscodeSubtitleEncodersInnerAtscCaptions object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewChannelTranscodeSubtitleEncodersInnerAtscCaptionsWithDefaults() *ChannelTranscodeSubtitleEncodersInnerAtscCaptions {
	this := ChannelTranscodeSubtitleEncodersInnerAtscCaptions{}
	return &this
}

// GetCea608 returns the Cea608 field value if set, zero value otherwise.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) GetCea608() int32 {
	if o == nil || IsNil(o.Cea608) {
		var ret int32
		return ret
	}
	return *o.Cea608
}

// GetCea608Ok returns a tuple with the Cea608 field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) GetCea608Ok() (*int32, bool) {
	if o == nil || IsNil(o.Cea608) {
		return nil, false
	}
	return o.Cea608, true
}

// HasCea608 returns a boolean if a field has been set.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) HasCea608() bool {
	if o != nil && !IsNil(o.Cea608) {
		return true
	}

	return false
}

// SetCea608 gets a reference to the given int32 and assigns it to the Cea608 field.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) SetCea608(v int32) {
	o.Cea608 = &v
}

// GetCta708 returns the Cta708 field value if set, zero value otherwise.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) GetCta708() int32 {
	if o == nil || IsNil(o.Cta708) {
		var ret int32
		return ret
	}
	return *o.Cta708
}

// GetCta708Ok returns a tuple with the Cta708 field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) GetCta708Ok() (*int32, bool) {
	if o == nil || IsNil(o.Cta708) {
		return nil, false
	}
	return o.Cta708, true
}

// HasCta708 returns a boolean if a field has been set.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) HasCta708() bool {
	if o != nil && !IsNil(o.Cta708) {
		return true
	}

	return false
}

// SetCta708 gets a reference to the given int32 and assigns it to the Cta708 field.
func (o *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) SetCta708(v int32) {
	o.Cta708 = &v
}

func (o ChannelTranscodeSubtitleEncodersInnerAtscCaptions) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ChannelTranscodeSubtitleEncodersInnerAtscCaptions) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Cea608) {
		toSerialize["cea608"] = o.Cea608
	}
	if !IsNil(o.Cta708) {
		toSerialize["cta708"] = o.Cta708
	}
	return toSerialize, nil
}

type NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions struct {
	value *ChannelTranscodeSubtitleEncodersInnerAtscCaptions
	isSet bool
}

func (v NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions) Get() *ChannelTranscodeSubtitleEncodersInnerAtscCaptions {
	return v.value
}

func (v *NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions) Set(val *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) {
	v.value = val
	v.isSet = true
}

func (v NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions) IsSet() bool {
	return v.isSet
}

func (v *NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableChannelTranscodeSubtitleEncodersInnerAtscCaptions(val *ChannelTranscodeSubtitleEncodersInnerAtscCaptions) *NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions {
	return &NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions{value: val, isSet: true}
}

func (v NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableChannelTranscodeSubtitleEncodersInnerAtscCaptions) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


