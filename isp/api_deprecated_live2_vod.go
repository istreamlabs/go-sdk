/*
 * WBD Aventus Channels API
 *
 * API version: v1.19.22
 * Contact: live-control-plane-devs@wbd.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package isp

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type DeprecatedLive2VODApi interface {

	/*
	DeprecatedClipGetMp4 Get MP4 URL

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [get-org-mp4-url](#get-/v2/-org-/channels/-channel-id-/vods/-vod_id-/clips/-clip-id-/mp4url) instead.</b>

Retrieves a playback URL for the MP4 playback for a clip if available.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@param vodId ID for a VOD
	@param clipId ID for a Clip
	@return ApiDeprecatedClipGetMp4Request

	Deprecated
	*/
	DeprecatedClipGetMp4(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedClipGetMp4Request

	// DeprecatedClipGetMp4Execute executes the request
	//  @return DeprecatedGetMp4UrlResponse
	// Deprecated
	DeprecatedClipGetMp4Execute(r ApiDeprecatedClipGetMp4Request) (*DeprecatedGetMp4UrlResponse, *http.Response, error)

	/*
	DeprecatedClipGetProgramTime Get Program Time

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [get-org-vod-clip-program-time](#get-/v2/-org-/channels/-channel-id-/vods/-vod_id-/clips/-clip-id-/programtime) instead.</b>

Retrieves Program Time for a given Clip

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@param vodId ID for a VOD
	@param clipId ID for a Clip
	@return ApiDeprecatedClipGetProgramTimeRequest

	Deprecated
	*/
	DeprecatedClipGetProgramTime(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedClipGetProgramTimeRequest

	// DeprecatedClipGetProgramTimeExecute executes the request
	//  @return DeprecatedGetProgramTimeResponse
	// Deprecated
	DeprecatedClipGetProgramTimeExecute(r ApiDeprecatedClipGetProgramTimeRequest) (*DeprecatedGetProgramTimeResponse, *http.Response, error)

	/*
	DeprecatedClipMakeMp4 Create MP4 for Clip

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [post-org-make-mp4](#post-/v2/-org-/channels/-channel-id-/vods/-vod_id-/clips/-clip-id-/makemp4) instead.</b>

Create a mp4 entity for the clip within a vod

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@param vodId ID for a VOD
	@param clipId ID for a Clip
	@return ApiDeprecatedClipMakeMp4Request

	Deprecated
	*/
	DeprecatedClipMakeMp4(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedClipMakeMp4Request

	// DeprecatedClipMakeMp4Execute executes the request
	//  @return DeprecatedMakeMP4Response
	// Deprecated
	DeprecatedClipMakeMp4Execute(r ApiDeprecatedClipMakeMp4Request) (*DeprecatedMakeMP4Response, *http.Response, error)

	/*
	DeprecatedGetClipManifest Get Manifests for Clip

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`.</b>

Retrieve List of Manifests for a given Clip

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@param vodId ID for a VOD
	@param clipId ID for a Clip
	@return ApiDeprecatedGetClipManifestRequest

	Deprecated
	*/
	DeprecatedGetClipManifest(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedGetClipManifestRequest

	// DeprecatedGetClipManifestExecute executes the request
	//  @return []DeprecatedGetClipManifestsResponseItem
	// Deprecated
	DeprecatedGetClipManifestExecute(r ApiDeprecatedGetClipManifestRequest) ([]DeprecatedGetClipManifestsResponseItem, *http.Response, error)

	/*
	GetDeprecatedClip Get clip

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`.</b>

Get the clip with the clip id sent in the request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@param vodId ID for a VOD
	@param clipId ID for a Clip
	@return ApiGetDeprecatedClipRequest

	Deprecated
	*/
	GetDeprecatedClip(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiGetDeprecatedClipRequest

	// GetDeprecatedClipExecute executes the request
	//  @return DeprecatedGetClipResponse
	// Deprecated
	GetDeprecatedClipExecute(r ApiGetDeprecatedClipRequest) (*DeprecatedGetClipResponse, *http.Response, error)

	/*
	GetDeprecatedProgram Get program

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`.</b>

Get a program with an customer, product and program id. This API is deprecated, and it only returns
the program from the west region.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@return ApiGetDeprecatedProgramRequest

	Deprecated
	*/
	GetDeprecatedProgram(ctx context.Context, customerId string, productId string, programId string) ApiGetDeprecatedProgramRequest

	// GetDeprecatedProgramExecute executes the request
	//  @return DeprecatedGetProgramResponse
	// Deprecated
	GetDeprecatedProgramExecute(r ApiGetDeprecatedProgramRequest) (*DeprecatedGetProgramResponse, *http.Response, error)

	/*
	ListDeprecatedClips List available clips

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [list-org-clips](#get-/v2/-org-/channels/-channel-id-/clips) instead.</b>

List all clips for the vod identified in the request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@param vodId ID for a VOD
	@return ApiListDeprecatedClipsRequest

	Deprecated
	*/
	ListDeprecatedClips(ctx context.Context, customerId string, productId string, programId string, vodId string) ApiListDeprecatedClipsRequest

	// ListDeprecatedClipsExecute executes the request
	//  @return []DeprecatedListClipsResponse
	// Deprecated
	ListDeprecatedClipsExecute(r ApiListDeprecatedClipsRequest) ([]DeprecatedListClipsResponse, *http.Response, error)

	/*
	ListDeprecatedVods List VODs

	<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [list-org-vods](#get-/v2/-org-/channels/-channel-id-/vods) instead.</b>

VODs can be listed after an appropriately configured channel is turned on for the first time.
If a channel with existing VODs is turned off or deleted, the VODs will still be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
	@param productId Product ID for a l2v request
	@param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
	@return ApiListDeprecatedVodsRequest

	Deprecated
	*/
	ListDeprecatedVods(ctx context.Context, customerId string, productId string, programId string) ApiListDeprecatedVodsRequest

	// ListDeprecatedVodsExecute executes the request
	//  @return []DeprecatedListVODsResponse
	// Deprecated
	ListDeprecatedVodsExecute(r ApiListDeprecatedVodsRequest) ([]DeprecatedListVODsResponse, *http.Response, error)
}

// DeprecatedLive2VODApiService DeprecatedLive2VODApi service
type DeprecatedLive2VODApiService service

type ApiDeprecatedClipGetMp4Request struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
	vodId string
	clipId string
}

func (r ApiDeprecatedClipGetMp4Request) Execute() (*DeprecatedGetMp4UrlResponse, *http.Response, error) {
	return r.ApiService.DeprecatedClipGetMp4Execute(r)
}

/*
DeprecatedClipGetMp4 Get MP4 URL

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [get-org-mp4-url](#get-/v2/-org-/channels/-channel-id-/vods/-vod_id-/clips/-clip-id-/mp4url) instead.</b>

Retrieves a playback URL for the MP4 playback for a clip if available.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @param vodId ID for a VOD
 @param clipId ID for a Clip
 @return ApiDeprecatedClipGetMp4Request

Deprecated
*/
func (a *DeprecatedLive2VODApiService) DeprecatedClipGetMp4(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedClipGetMp4Request {
	return ApiDeprecatedClipGetMp4Request{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
		vodId: vodId,
		clipId: clipId,
	}
}

// Execute executes the request
//  @return DeprecatedGetMp4UrlResponse
// Deprecated
func (a *DeprecatedLive2VODApiService) DeprecatedClipGetMp4Execute(r ApiDeprecatedClipGetMp4Request) (*DeprecatedGetMp4UrlResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeprecatedGetMp4UrlResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.DeprecatedClipGetMp4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod/{vod_id}/clip/{clip-id}/mp4url"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vod_id"+"}", url.PathEscape(parameterToString(r.vodId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clip-id"+"}", url.PathEscape(parameterToString(r.clipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.(*DeprecatedGetMp4UrlResponse)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeprecatedClipGetProgramTimeRequest struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
	vodId string
	clipId string
}

func (r ApiDeprecatedClipGetProgramTimeRequest) Execute() (*DeprecatedGetProgramTimeResponse, *http.Response, error) {
	return r.ApiService.DeprecatedClipGetProgramTimeExecute(r)
}

/*
DeprecatedClipGetProgramTime Get Program Time

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [get-org-vod-clip-program-time](#get-/v2/-org-/channels/-channel-id-/vods/-vod_id-/clips/-clip-id-/programtime) instead.</b>

Retrieves Program Time for a given Clip

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @param vodId ID for a VOD
 @param clipId ID for a Clip
 @return ApiDeprecatedClipGetProgramTimeRequest

Deprecated
*/
func (a *DeprecatedLive2VODApiService) DeprecatedClipGetProgramTime(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedClipGetProgramTimeRequest {
	return ApiDeprecatedClipGetProgramTimeRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
		vodId: vodId,
		clipId: clipId,
	}
}

// Execute executes the request
//  @return DeprecatedGetProgramTimeResponse
// Deprecated
func (a *DeprecatedLive2VODApiService) DeprecatedClipGetProgramTimeExecute(r ApiDeprecatedClipGetProgramTimeRequest) (*DeprecatedGetProgramTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeprecatedGetProgramTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.DeprecatedClipGetProgramTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod/{vod_id}/clip/{clip-id}/programtime"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vod_id"+"}", url.PathEscape(parameterToString(r.vodId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clip-id"+"}", url.PathEscape(parameterToString(r.clipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.(*DeprecatedGetProgramTimeResponse)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeprecatedClipMakeMp4Request struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
	vodId string
	clipId string
	deprecatedMakeMP4Request *DeprecatedMakeMP4Request
}

func (r ApiDeprecatedClipMakeMp4Request) DeprecatedMakeMP4Request(deprecatedMakeMP4Request DeprecatedMakeMP4Request) ApiDeprecatedClipMakeMp4Request {
	r.deprecatedMakeMP4Request = &deprecatedMakeMP4Request
	return r
}

func (r ApiDeprecatedClipMakeMp4Request) Execute() (*DeprecatedMakeMP4Response, *http.Response, error) {
	return r.ApiService.DeprecatedClipMakeMp4Execute(r)
}

/*
DeprecatedClipMakeMp4 Create MP4 for Clip

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [post-org-make-mp4](#post-/v2/-org-/channels/-channel-id-/vods/-vod_id-/clips/-clip-id-/makemp4) instead.</b>

Create a mp4 entity for the clip within a vod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @param vodId ID for a VOD
 @param clipId ID for a Clip
 @return ApiDeprecatedClipMakeMp4Request

Deprecated
*/
func (a *DeprecatedLive2VODApiService) DeprecatedClipMakeMp4(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedClipMakeMp4Request {
	return ApiDeprecatedClipMakeMp4Request{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
		vodId: vodId,
		clipId: clipId,
	}
}

// Execute executes the request
//  @return DeprecatedMakeMP4Response
// Deprecated
func (a *DeprecatedLive2VODApiService) DeprecatedClipMakeMp4Execute(r ApiDeprecatedClipMakeMp4Request) (*DeprecatedMakeMP4Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeprecatedMakeMP4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.DeprecatedClipMakeMp4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod/{vod_id}/clip/{clip-id}/_makemp4"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vod_id"+"}", url.PathEscape(parameterToString(r.vodId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clip-id"+"}", url.PathEscape(parameterToString(r.clipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deprecatedMakeMP4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 408 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.(*DeprecatedMakeMP4Response)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeprecatedGetClipManifestRequest struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
	vodId string
	clipId string
}

func (r ApiDeprecatedGetClipManifestRequest) Execute() ([]DeprecatedGetClipManifestsResponseItem, *http.Response, error) {
	return r.ApiService.DeprecatedGetClipManifestExecute(r)
}

/*
DeprecatedGetClipManifest Get Manifests for Clip

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`.</b>

Retrieve List of Manifests for a given Clip

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @param vodId ID for a VOD
 @param clipId ID for a Clip
 @return ApiDeprecatedGetClipManifestRequest

Deprecated
*/
func (a *DeprecatedLive2VODApiService) DeprecatedGetClipManifest(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiDeprecatedGetClipManifestRequest {
	return ApiDeprecatedGetClipManifestRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
		vodId: vodId,
		clipId: clipId,
	}
}

// Execute executes the request
//  @return []DeprecatedGetClipManifestsResponseItem
// Deprecated
func (a *DeprecatedLive2VODApiService) DeprecatedGetClipManifestExecute(r ApiDeprecatedGetClipManifestRequest) ([]DeprecatedGetClipManifestsResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeprecatedGetClipManifestsResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.DeprecatedGetClipManifest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod/{vod_id}/clip/{clip-id}/clipManifest"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vod_id"+"}", url.PathEscape(parameterToString(r.vodId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clip-id"+"}", url.PathEscape(parameterToString(r.clipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.([]DeprecatedGetClipManifestsResponseItem)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeprecatedClipRequest struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
	vodId string
	clipId string
}

func (r ApiGetDeprecatedClipRequest) Execute() (*DeprecatedGetClipResponse, *http.Response, error) {
	return r.ApiService.GetDeprecatedClipExecute(r)
}

/*
GetDeprecatedClip Get clip

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`.</b>

Get the clip with the clip id sent in the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @param vodId ID for a VOD
 @param clipId ID for a Clip
 @return ApiGetDeprecatedClipRequest

Deprecated
*/
func (a *DeprecatedLive2VODApiService) GetDeprecatedClip(ctx context.Context, customerId string, productId string, programId string, vodId string, clipId string) ApiGetDeprecatedClipRequest {
	return ApiGetDeprecatedClipRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
		vodId: vodId,
		clipId: clipId,
	}
}

// Execute executes the request
//  @return DeprecatedGetClipResponse
// Deprecated
func (a *DeprecatedLive2VODApiService) GetDeprecatedClipExecute(r ApiGetDeprecatedClipRequest) (*DeprecatedGetClipResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeprecatedGetClipResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.GetDeprecatedClip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod/{vod_id}/clip/{clip-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vod_id"+"}", url.PathEscape(parameterToString(r.vodId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clip-id"+"}", url.PathEscape(parameterToString(r.clipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.(*DeprecatedGetClipResponse)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeprecatedProgramRequest struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
}

func (r ApiGetDeprecatedProgramRequest) Execute() (*DeprecatedGetProgramResponse, *http.Response, error) {
	return r.ApiService.GetDeprecatedProgramExecute(r)
}

/*
GetDeprecatedProgram Get program

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`.</b>

Get a program with an customer, product and program id. This API is deprecated, and it only returns
the program from the west region.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @return ApiGetDeprecatedProgramRequest

Deprecated
*/
func (a *DeprecatedLive2VODApiService) GetDeprecatedProgram(ctx context.Context, customerId string, productId string, programId string) ApiGetDeprecatedProgramRequest {
	return ApiGetDeprecatedProgramRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
	}
}

// Execute executes the request
//  @return DeprecatedGetProgramResponse
// Deprecated
func (a *DeprecatedLive2VODApiService) GetDeprecatedProgramExecute(r ApiGetDeprecatedProgramRequest) (*DeprecatedGetProgramResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeprecatedGetProgramResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.GetDeprecatedProgram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.(*DeprecatedGetProgramResponse)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeprecatedClipsRequest struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
	vodId string
}

func (r ApiListDeprecatedClipsRequest) Execute() ([]DeprecatedListClipsResponse, *http.Response, error) {
	return r.ApiService.ListDeprecatedClipsExecute(r)
}

/*
ListDeprecatedClips List available clips

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [list-org-clips](#get-/v2/-org-/channels/-channel-id-/clips) instead.</b>

List all clips for the vod identified in the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @param vodId ID for a VOD
 @return ApiListDeprecatedClipsRequest

Deprecated
*/
func (a *DeprecatedLive2VODApiService) ListDeprecatedClips(ctx context.Context, customerId string, productId string, programId string, vodId string) ApiListDeprecatedClipsRequest {
	return ApiListDeprecatedClipsRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
		vodId: vodId,
	}
}

// Execute executes the request
//  @return []DeprecatedListClipsResponse
// Deprecated
func (a *DeprecatedLive2VODApiService) ListDeprecatedClipsExecute(r ApiListDeprecatedClipsRequest) ([]DeprecatedListClipsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeprecatedListClipsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.ListDeprecatedClips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod/{vod_id}/clip"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vod_id"+"}", url.PathEscape(parameterToString(r.vodId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.([]DeprecatedListClipsResponse)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeprecatedVodsRequest struct {
	ctx context.Context
	ApiService DeprecatedLive2VODApi
	customerId string
	productId string
	programId string
}

func (r ApiListDeprecatedVodsRequest) Execute() ([]DeprecatedListVODsResponse, *http.Response, error) {
	return r.ApiService.ListDeprecatedVodsExecute(r)
}

/*
ListDeprecatedVods List VODs

<b>This route is deprecated and is subject to removal any time after `Thu, 06 Apr 2023 19:00:00 UTC`. Use [list-org-vods](#get-/v2/-org-/channels/-channel-id-/vods) instead.</b>

VODs can be listed after an appropriately configured channel is turned on for the first time.
If a channel with existing VODs is turned off or deleted, the VODs will still be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId Customer ID for a l2v request.  Used only for the deprecated legacy route support.
 @param productId Product ID for a l2v request
 @param programId Program ID for a l2v request.  Used only for the deprecated legacy route support.
 @return ApiListDeprecatedVodsRequest

Deprecated
*/
func (a *DeprecatedLive2VODApiService) ListDeprecatedVods(ctx context.Context, customerId string, productId string, programId string) ApiListDeprecatedVodsRequest {
	return ApiListDeprecatedVodsRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
		productId: productId,
		programId: programId,
	}
}

// Execute executes the request
//  @return []DeprecatedListVODsResponse
// Deprecated
func (a *DeprecatedLive2VODApiService) ListDeprecatedVodsExecute(r ApiListDeprecatedVodsRequest) ([]DeprecatedListVODsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeprecatedListVODsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeprecatedLive2VODApiService.ListDeprecatedVods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cust/{customer-id}/prod/{product-id}/prog/{program-id}/vod"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", url.PathEscape(parameterToString(r.customerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product-id"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"program-id"+"}", url.PathEscape(parameterToString(r.programId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.programId) > 60 {
		return localVarReturnValue, nil, reportError("programId must have less than 60 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if disablePaging := r.ctx.Value(ContextDisablePaging); disablePaging == nil {
		if uri := GetLink(localVarHTTPResponse, RelNext); uri != nil {
			// This response is paginated. Read all the pages and append the items.
			items, resp, err := getAllPages(a.client, localVarReturnValue, localVarHTTPResponse)
			if err.Error() != "" {
				return localVarReturnValue, localVarHTTPResponse, err
			}
			localVarReturnValue = items.([]DeprecatedListVODsResponse)
			localVarHTTPResponse = resp
		}
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
